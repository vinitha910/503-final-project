# -*- coding: utf-8 -*-
"""CSE503_Robotics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10FY0on2IlEoRVSdSL24hknGaBqMHt0OE
"""

#import pygame
import math
from math import cos, sin
import numpy as np

class Obstacle:
  def __init__(self, length_m, width_m, x_m, y_m, theta_rad):
    self.length_m = length_m
    self.width_m = width_m
    self.theta_rad = theta_rad
    self.x_m = x_m
    self.y_m = y_m
    self.find_corners()

  def find_corners(self):
    top_left = (self.x_m - self.width_m/2, self.y_m + self.length_m/2)
    top_right =  (self.x_m + self.width_m/2, self.y_m + self.length_m/2)
    bottom_right = (self.x_m + self.width_m/2, self.y_m - self.length_m/2)
    bottom_left = (self.x_m - self.width_m/2, self.y_m - self.length_m/2)
    self.corners = [top_left, top_right, bottom_right, bottom_left]

class Environment:
  def __init__ (self, length_m, width_m, resolution_m):
      self.length_m = length_m
      self.width_m = width_m
      self.resolution_m = resolution_m
      self.obstacles = []

  # checks if x,y is in bounds of environemnt
  def is_in_bounds(self, corner):
    if ((corner > self.length_m) | (corner < 0.0) | (corner > self.width_m)):
      return False #Out of bounds
    return True
  
  # checks if state is valid (i.e. not in collision and is in bounds)
  def is_valid(self):
    if (is_in_bounds & ~isCollsion):
      return True
    return False

  def create_obstacle(self, length_m, width_m, x_m, y_m, angle_rad):
    #Send each corner's x/y coordinates
    for obstacle in self.obstacles:
      for corner in obstacle.corners:
        self.is_in_bounds(corner)
    obs = Obstacle(length_m, width_m, x_m, y_m, angle_rad)
    self.obstacles.append(obs)
    return obs 

  def rotate(self, angle_rad):
    for i in range(len(self.corners)):
        x = self.corners[i][0]
        y = self.corners[i][1]
        theta = angle_rad - self.theta_rad
        rotated_x = self.x_m + (x - self.x_m)*cos(theta) + (y - self.x_m)*sin(theta)
        rotated_y = self.x_m - (x - self.x_m)*sin(theta) + (y - self.x_m)*cos(theta)
        self.corners[i] = (rotated_x, rotated_y) 
    self.theta_rad = angle_rad

  def isCollision(self, x, y, theta):
    #Assuming robot as a single point (x,y,theta) is passed in
    #continuous analysis
    #https://gamedev.stackexchange.com/questions/128598/collision-detection-point-hitting-a-rotating-rectangle
    for obs in self.obstacles:
      print("in obs loop")
      sinus   = sin(theta)
      cosinus = cos(theta)
      temp = np.array([0,0])

      center_of_object = np.array([obs.x_m, obs.y_m])
      point = np.array([x,y])

      #rotate point and obstactle about angle to more easily calculate bounds
      point  = np.subtract(point, center_of_object);
      #temp[0] = temp x-coord
      temp[0] = point[0] * cosinus - point[1] * sinus;
      temp[1] = point[0] * sinus   + point[1] * cosinus;
      point  =  np.add(temp, center_of_object);
      
      #if point (x,y) is within or on lines between any of the corners, return true
      #self.corners = [top_left, top_right, bottom_right, bottom_left]
      # point.x > bottom_left.x && point.x < top_right.x 
      #    && point.y > bottom_left.y && point.y < top_right.y -> inside object
      print("point.x: ", point[0], " point.y: ", point[1])
      if((point[0] > obs.corners[3][0]) & (point[0] < obs.corners[1][0]) & (point[1] > obs.corners[3][1]) & (point[1] < obs.corners[1][1])):
        return True #collision!

    return False #no collision

def test():
  env = Environment(5, 5, 1)
  testObs = env.create_obstacle(2, 2, 2.5, 2.5, 0)
  print(testObs.x_m, testObs.y_m, testObs.corners[3]) #Expected 2.5, 2.5
  #Big square environment with slightly smaller square obstacle, centered and not rotated
  #testObs.rotate(3)
  print(testObs.x_m, testObs.y_m, testObs.corners[1]) #Expected 2.5, 2.5
  collide = env.isCollision(2.5, 2.5, 0)
  print(collide)

test()